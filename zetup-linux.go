package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"
	"os/signal"
	"strings"
	"syscall"

	uuid "github.com/satori/go.uuid"
	"golang.org/x/crypto/ssh/terminal"
)

var USER_INFO_FILE = ""
var ZETUP_CONFIG_DIR = ""
var ZETUP_INSTALLATION_ID = ""

// Note: will support gitlab when https://gitlab.com/gitlab-org/gitlab-ce/issues/27954 goes through

// maintain symbolic link to
// git repo
func ZetupLinux() {
	// get sudo privileges
	cmd := exec.Command("sudo", "echo", "have sudo privileges")
	err := cmd.Start()
	if err != nil {
		log.Fatal(err)
	}
	err = cmd.Wait()

	// create unique installation ID
	hostname, err := os.Hostname()
	if err != nil {
		panic(err)
	}
	username := os.Getenv("USER")
	idNum := uuid.NewV4()
	ZETUP_INSTALLATION_ID = fmt.Sprintf("zetup %v %v %v", hostname, username, idNum)

	// create directories
	homedir, err := os.UserHomeDir()
	if err != nil {
		log.Fatal(err)
	}
	ZETUP_BACKUP_DIR := fmt.Sprintf("%v/.zetup/.bak", homedir)
	err = os.MkdirAll(ZETUP_BACKUP_DIR, 0755)
	if err != nil {
		log.Fatal(err)
	}
	ZETUP_CONFIG_DIR = fmt.Sprintf("%v/.config/zetup", homedir)
	err = os.MkdirAll(ZETUP_CONFIG_DIR, 0755)
	if err != nil {
		log.Fatal(err)
	}
	githubToken := getToken()
	log.Println("hello world")
	log.Printf("githubToken = %+v\n", githubToken)
	USER_INFO_FILE = fmt.Sprintf("%v/user_info.json", ZETUP_CONFIG_DIR)
	userInfo := getUserInfo(githubToken)
	log.Printf("userInfo = %+v\n", userInfo)

}

type UserInfo struct {
	Username string `json:"login"`
	Email    string `json:"email"`
	Name     string `json:"name"`
}

func getUserInfo(githubToken string) UserInfo {
	var userInfo UserInfo

	// if user info file exists, use that
	if _, err := os.Stat(USER_INFO_FILE); err == nil {
		jsonFile, err := os.Open(USER_INFO_FILE)
		if err != nil {
			log.Fatal(err)
		}
		byteValue, _ := ioutil.ReadAll(jsonFile)
		json.Unmarshal(byteValue, &userInfo)
		return userInfo
	}

	// get info with personal access token

	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

	req, err := http.NewRequest("GET", "https://api.github.com/user", nil)
	if err != nil {
		log.Fatal(err)
	}
	tokenHeader := fmt.Sprintf("token %v", githubToken)
	log.Printf("tokenHeader = %+v\n", tokenHeader)
	req.Header.Set("Authorization", tokenHeader)

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		log.Fatal(err)
	}

	defer resp.Body.Close()

	decoder := json.NewDecoder(resp.Body)
	err = decoder.Decode(&userInfo)
	if err != nil {
		log.Fatal(err)
	}

	// write token to file
	file, _ := json.MarshalIndent(userInfo, "", " ")
	_ = ioutil.WriteFile(USER_INFO_FILE, file, 0644)
	return userInfo

}

type TokenInfo struct {
	Id    int    `json:"id"`
	Token string `json:"token"`
}

var TOKEN_INFO_FILE string

func getToken() string {
	// if the github token environment variable is set use that
	envVar := os.Getenv("ZETUP_GITHUB_TOKEN")
	if len(envVar) > 0 {
		return envVar
	}

	// if the token info file exists, parse that
	TOKEN_INFO_FILE = fmt.Sprintf("%v/github_personal_access_token_info.json", ZETUP_CONFIG_DIR)
	if _, err := os.Stat(TOKEN_INFO_FILE); err == nil {
		jsonFile, err := os.Open(TOKEN_INFO_FILE)
		if err != nil {
			log.Fatal(err)
		}
		byteValue, _ := ioutil.ReadAll(jsonFile)
		var tokenInfo TokenInfo
		json.Unmarshal(byteValue, &tokenInfo)
		return tokenInfo.Token
	}

	// no token present, so create
	return createToken()
}

type TokenPayload struct {
	Note   string   `json:"note"`
	Scopes []string `json:"scopes"`
}

func createToken() string {
	// get github username and password
	username := os.Getenv("GITHUB_USERNAME")
	if len(username) == 0 {
		reader := bufio.NewReader(os.Stdin)
		username = os.Getenv("USER")
		fmt.Printf("Github Username (%v): ", username)
		enteredUsername, err := reader.ReadString('\n')
		enteredUsername = strings.Trim(enteredUsername, " ")
		if err != nil {
			log.Fatal(err)
		}
	} else {
		fmt.Println("Using Github Username ", username)
	}

	password := os.Getenv("GITHUB_PASSWORD")
	if len(password) == 0 {
		password = getPassword("Github Password: ")
	}

	// send token request
	data := TokenPayload{
		Note: ZETUP_INSTALLATION_ID,
		Scopes: []string{
			"repo",
			"admin:org",
			"admin:public_key",
			"admin:repo_hook",
			"gist",
			"notifications",
			"user",
			"delete_repo",
			"write:discussion",
			"admin:gpg_key",
		},
	}
	payloadBytes, err := json.Marshal(data)
	if err != nil {
		log.Fatal(err)
	}
	body := bytes.NewReader(payloadBytes)

	req, err := http.NewRequest("POST", "https://api.github.com/authorizations", body)
	if err != nil {
		log.Fatal(err)
	}

	req.SetBasicAuth(username, password)
	req.Header.Set("Content-Type", "application/json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		log.Fatal(err)
	}

	defer resp.Body.Close()

	decoder := json.NewDecoder(resp.Body)
	var respTokenData TokenInfo
	err = decoder.Decode(&respTokenData)
	if err != nil {
		log.Fatal(err)
	}

	// write token to file
	file, _ := json.MarshalIndent(respTokenData, "", " ")
	_ = ioutil.WriteFile(TOKEN_INFO_FILE, file, 0644)
	return respTokenData.Token
}

/*
* Not my code â†“
 */
func getPassword(prompt string) string {
	// Get the initial state of the terminal.
	initialTermState, e1 := terminal.GetState(syscall.Stdin)
	if e1 != nil {
		panic(e1)
	}

	// Restore it in the event of an interrupt.
	// CITATION: Konstantin Shaposhnikov - https://groups.google.com/forum/#!topic/golang-nuts/kTVAbtee9UA

	c := make(chan os.Signal)
	signal.Notify(c, os.Interrupt, os.Kill)
	go func() {
		<-c
		_ = terminal.Restore(syscall.Stdin, initialTermState)
		os.Exit(1)
	}()

	// Now get the password.
	fmt.Print(prompt)
	p, err := terminal.ReadPassword(syscall.Stdin)
	fmt.Println("")
	if err != nil {
		panic(err)
	}

	// Stop looking for ^C on the channel.
	signal.Stop(c)

	// Return the password as a string.
	return string(p)
}
